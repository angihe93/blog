---
title: 'Fractal Bootcamp Week 5 Reflection - No room for slop'
publishedAt: '2025-07-06'
summary: '...'
---

It's been a week since I committed to working on my prediction markets project full-time. Because I have time now, I actually have to turn my prototype code into something good and production-grade. While the prototype stage was more about figuring out the right flow and learning how the exchanges' APIs and websockets work, now we are aiming to get to fully systematic trading that performs consistently.

The idea of arbitrage is simple (buy the cheaper side of an event on each exchange and make a riskless profit at expiration), but a lot needs to go right for a systematic arbitrage strategy to work. For instance our copy of the orderbooks should correctly reflect the up to date exchange levels, and critically the prices we buy the contracts at are the same as what we found when the system identified the arbitrage, but this is hard due to slippage, especially in fast moving volatile markets where arbitrage opportunities tend to occur. From previous test trade sessions, it seems like market orders are off limits as prices move against us way too often, so we recently switched to placing limit orders instead, which also introduces its own set of complexities such as monitoring order fills and deciding what to do when both legs don't fill to the same amount and we have risk exposures. There is a lot of analytics we could do to better understand price movements on these markets, but this will be a longer term project as our priority now is to get the system ready to handle more live trading asap. Basically get it to a point where we can trust that it will do okay if we leave it unattended.

So I have to sit with my old code, fit the components into our new architecture, and build for leanness and scalability. I have to audit every line of my code and make sure it is both correct and efficient. I have to deal with the fact that some things I did before for the interest of time may not be okay anymore. For example one such thing was how I just ran all the components in one thread, so it was passing data from one class to the next and acting on the signals and trades sequentially. However because certain components take longer to run than others (eg. the trade engine that places trades via the exchanges' APIs), it introduced latency to the whole system and sometimes when it was acting on the next signal to trade it was already stale compared to the actual exchange prices. So I thought about how to deal with this, and I realized making the program multi-threaded should help, with one thread updating the market data and another thread placing the trades. They would communicate via a shared data source which would be updated more frequently with live markets data, so the trade engine should be able to see and act on fresher signals. I'm pretty new to multi-threaded programming though, and some of this seems a bit intimidating, but it's new and exciting to me as well. I feel like I'm unlocking new powers as a python programmer.

I don't think I've ever worked on something this technically demanding, and I honestly feel a bit unqualified at times, but I'm glad to have my teammates to talk things over and bounce ideas off of. I hope building this trading system will stretch me to grow in new ways as a developer.

I missed out on the bootcamp curriculum stuff this week, which covered React Native and Cursor. From what I saw they seemed like powerful tools for app building, and I'd love to check them out more when I have time. On Saturday I got to see my classmates' demos of their apps, and they were quite delightful. They ran the gamut of weather social, tennis coaching, recipe generation, game rating, language learning, and more. I also learned something new about Rust and emulators from classmates that worked on different projects.